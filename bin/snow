#!/bin/bash
# This is the sNow! Command Line Interface 
# Developed by Jordi Blasco <jordi.blasco@hpcnow.com>
# For more information, visit the official website : www.hpcnow.com/snow
#
#set -xv
SNOWPATH=$(dirname "$0")
PROGNAME=$(basename "$0")
# Load the configuration
SNOW_PATH=/sNow
SNOW_HOME=$SNOW_PATH/home
SNOW_SOFT=$SNOW_PATH/easybuild
SNOW_CONF=$SNOW_PATH/snow-configspace
SNOW_UTIL=$SNOW_PATH/snow-utils
SNOW_TOOL=$SNOW_PATH/snow-tools
CONFIG_FILE=$SNOWPATH/../etc/snow.conf
ENTERPRISE_EXTENSIONS=$SNOWPATH/enterprise_extensions.sh
SNOW_DOMAINS=$SNOWPATH/../etc/domains.conf
SNOW_ACTIVE_DOMAINS=$SNOWPATH/../etc/active-domains.conf
SELF_ACTIVE_DOMAINS=$(cat $SNOW_DOMAINS | grep -v ^# | gawk '{print $1}' || echo "no gawk")
HAS_EE=false
DOWNLD=wget
declare -A CLUSTERS
opt1=$1
opt2=$2
opt3=$3
opt4=$4
opt5=$5

if [[ -f $CONFIG_FILE ]]; then
    source $CONFIG_FILE
    export PDSH_RCMD_TYPE
fi

if [[ -f $ENTERPRISE_EXTENSIONS ]]; then
    source $ENTERPRISE_EXTENSIONS
    HAS_EE=true
fi

if ! [[ -d $SNOW_PATH/log ]]; then
    mkdir $SNOW_PATH/log
fi

function error_exit(){
    echo "${PROGNAME}: ${1:-"Unknown Error: Please report the issue to https://bitbucket.org/hpcnow/snow-tools/issues"}" 1>&2
    exit 1
}

function shelp(){
echo " 
This is the sNow! Command Line Interface
Developed by Jordi Blasco <jordi.blasco@hpcnow.com>
For more information, visit the official website : www.hpcnow.com

Usage: snow [function] <option|domain|server>

Function List:

    * init                           | setup the system according to the parameters defined in snow.conf and active-domains.conf
    * config                         | shows the sNow! configuration based on the changes applied in snow.conf and domains.conf
    * update tools                   | updates the sNow! Tools 
    * update configspace             | updates configuration files from private git 
    * update template                | updates the sNow! image used to create new domains
    * deploy <domain|server>         | deploy specific domain/server 
    * remove <domain>                | removes an existing domain deployed with sNow!
    * list                           | list current domains (services) and their status
    * boot <domain|server>           | boot specific domain or server
    * boot domains                   | boot all the domains (all services not available under sNow! HA)
    * boot cluster <clustername>     | boot all the compute nodes of the selected cluster (by default 20 nodes at once)
    * reboot <domain|server>         | reboot specific domain or server
    * shutdown <domain|server>       | shutdown specific domain or server
    * shutdown cluster <clustername> | shutdown all the compute nodes of the selected cluster
    * destroy <domain|server>        | force to stop specific domain or server
    * reset <domain|server>          | force to reboot specific domain or server
    * poweroff <domain|server>       | force to shutdown specific domain or server simulating a power button press
    * console <domain|server>        | console access to specific domain or server
    * uptime <domain|sever>          | shows uptime of specific domain or server
    * cmd <domain|sever> <command>   | executes a command in the domain(s) or server(s)

Examples:

    snow update tools
    snow deploy ldap01
    snow cmd n[001-999] uname
"
}

function config() {
if [[ ! -f $SNOW_DOMAINS ]]; then
    echo "No $SNOW_DOMAINS found"
else
    cat $SNOW_PATH/snow-tools/etc/snow.conf
    echo "==== Active Domains ===="
    cat $SNOW_PATH/snow-tools/etc/active-domains.conf | grep -v ^# |  gawk '{print $0}'
fi
}

if [[ ! $HAS_EE ]]; then
    function takeover() {
        echo "The takeover feature is only available in sNow! Enterprise Edition"
    }
fi

function download() {
    case $DOWNLD in
        axel) 
            axel -q -n 10 $1 -o $2 
        ;;
        wget)
            wget -q -P $2 $1
        ;;
        *) 
            error_exit "Error: $DOWNLD is not supported"
        ;;
    esac
}

function bkp() {
    bkpfile=$1
    next=$(date +%Y%m%d%H%M)
    cp -pr $bkpfile $bkpfile.$next-snow
}

function prefix_to_bit_netmask() {
    prefix=$1;
    shift=$(( 32 - prefix ));
    bitmask=""
    for (( i=0; i < 32; i++ )); do
        num=0
        if [ $i -lt $prefix ]; then
            num=1
        fi
        space=
        if [ $(( i % 8 )) -eq 0 ]; then
            space=" ";
        fi
        bitmask="${bitmask}${space}${num}"
    done
    echo $bitmask
}

function bit_netmask_to_wildcard_netmask() {
    bitmask=$1;
    wildcard_mask=
    for octet in $bitmask; do
        wildcard_mask="${wildcard_mask} $(( 255 - 2#$octet ))"
    done
    echo $wildcard_mask;
}

function mask2cidr() {
    nbits=0
    IFS=.
    for dec in $1 ; do
        case $dec in
            255) let nbits+=8;;
            254) let nbits+=7;;
            252) let nbits+=6;;
            248) let nbits+=5;;
            240) let nbits+=4;;
            224) let nbits+=3;;
            192) let nbits+=2;;
            128) let nbits+=1;;
            0);;
            *) error_exit "Error: $dec is not recognised"
        esac
    done
    echo "$nbits"
}

function generate_hostlist() {
    ip=$1
    host_extension=$2
    net=$(echo $ip | cut -d '/' -f 1);
    prefix=$(echo $ip | cut -d '/' -f 2);
    if [[ $prefix =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
        cidr=$(mask2cidr $prefix)
    else
        cidr=$prefix
    fi
    bit_netmask=$(prefix_to_bit_netmask $cidr);
    wildcard_mask=$(bit_netmask_to_wildcard_netmask "$bit_netmask");
    str=
    for (( i = 1; i <= 4; i++ )); do
        range=$(echo $net | cut -d '.' -f $i)
        mask_octet=$(echo $wildcard_mask | cut -d ' ' -f $i)
        if [ $mask_octet -gt 0 ]; then
            range="{$range..$(( $range | $mask_octet ))}";
        fi
        str="${str} $range"
    done
    ips=$(echo $str | sed "s, ,\\.,g"); 
    hostip=( $(eval echo $ips | tr ' ' '\n') )
    if (( "${#host[@]}" > "${#hostip[@]}" )); then
        error_exit "Error: the /etc/hosts can NOT be generated because the IP rank is too short!"
    fi
    for (( i=0; i<${#host[@]}; i++ ));
    do 
        printf "%s %20s\n" "${hostip[$i]}" "${host[$i]}$host_extension"
    done
}


function init() {
    if [[ ! $HA_NFSROOT ]]; then
        # NFS_ROOT Exports
        if [[ ! -d /etc/exports.d ]]; then
           mkdir -p /etc/exports.d
        fi
        if [[ ! -f $SNOW_CONF/system_files/etc/exports.d/snow.exports ]]; then
            if [[ ! -d $SNOW_CONF/system_files/etc/exports.d ]]; then
                mkdir -p $SNOW_CONF/system_files/etc/exports.d
            fi
            gawk -v snow01=${SNOWNODES[0]} -v snow02=${SNOWNODES[1]} '{
                if ($1 !~ /^#|snow/){
                    print "/sNow/"$1"\t "snow01"(rw,sync,no_subtree_check,no_root_squash) "snow02"(rw,sync,no_subtree_check,no_root_squash) " $1"(rw,sync,no_subtree_check,no_root_squash)"
                }
            }' $SNOW_ACTIVE_DOMAINS > $SNOW_CONF/system_files/etc/exports.d/snow.exports
            ln -sf $SNOW_CONF/system_files/etc/exports.d/snow.exports /etc/exports.d/snow.exports
            echo "Review the following exports file : $SNOW_CONF/system_files/etc/exports.d/snow.exports"
            echo "Once you are done, execute exportfs -u"
        fi
    fi
    #If the master is the NFS Server it will setup the $SNOW_CONF/system_files/etc/exports.d/snow.exports
    if [[ "$(uname -n)" == "$NFS_SERVER" ]]; then
        if [[ ! -f $SNOW_CONF/system_files/etc/exports.d/snow.exports ]]; then 
            if [[ ! -d $SNOW_CONF/system_files/etc/exports.d ]]; then
                mkdir -p $SNOW_CONF/system_files/etc/exports.d
            fi
            echo "/sNow            ${NET_SNOW[2]}0/${NET_SNOW[3]}(rw,sync,no_subtree_check,no_root_squash)" >> $SNOW_CONF/system_files/etc/exports.d/snow.exports
            echo "Review the following exports file : $SNOW_CONF/system_files/etc/exports.d/snow.exports"
            echo "Once you are done, execute exportfs -rv"
        fi
        if [[ ! -d /etc/exports.d ]]; then
            mkdir -p /etc/exports.d
        fi
        ln -sf $SNOW_CONF/system_files/etc/exports.d/snow.exports /etc/exports.d/snow.exports
    fi
    # sNow! Domains configuration table
    if [[ ! -d $SNOW_CONF/system_files/etc/exports.d ]]; then
        cat $SNOW_TOOL/etc/domains.conf-example > $SNOW_TOOL/etc/domains.conf
        gawk -v brdmz=${NET_DMZ[0]} -v gwdmz=${NET_DMZ[1]} -v netdmz=${NET_DMZ[2]} -v maskdmz=${NET_DMZ[3]} \
             -v brsnow=${NET_SNOW[0]} -v gwsnow=${NET_SNOW[1]} -v netsnow=${NET_SNOW[2]} -v masksnow=${NET_SNOW[3]} \
            'BEGIN{i=0}{
                i=i+1
                printf "%12s\t %20s %6s %16s %9s 76:fd:31:9e:%02i:%2s %16s %16s %6s %16s %9s 76:fd:31:9e:%02i:%2s %16s %16s \n", $1, $2, "eth0", netsnow""i, brsnow, i, "01", masksnow, gwsnow, "eth1", netdmz""i, brdmz, i, "02", maskdmz, gwdmz  
            }' -f $SNOW_ACTIVE_DOMAINS >> $SNOW_TOOL/etc/domains.conf
        echo "Review the domains config file : $SNOW_TOOL/etc/domains.conf"
    fi
    # Generate /etc/hosts based on the sNow! domains and compute node list defined in snow.conf (parameter CLUSTERS)
    host=( )
    for i in "${!CLUSTERS[@]}"
    do 
        node_rank ${CLUSTERS[$i]}
        host+=( $(eval echo "$NPREFIX{${NRANK[0]}..${NRANK[1]}}") )
    done
    bkp /etc/hosts
    generate_hostlist ${NET_SNOW[2]}100/${NET_SNOW[3]} "${NET_SNOW[4]}" >> /etc/hosts
    generate_hostlist ${NET_IPMI[2]}100/${NET_IPMI[3]} "${NET_IPMI[4]}" >> /etc/hosts
    generate_hostlist ${NET_LLF[2]}100/${NET_LLF[3]} "${NET_LLF[4]}" >> /etc/hosts
    cp -p /etc/hosts $SNOW_CONF/system_files/etc/hosts 

    # Generate /etc/ssh/ssh_known_hosts
    bkp /etc/ssh/ssh_known_hosts
    echo "$(echo ${host[*]} | sed 's/ /,/g') $(cat /etc/ssh/ssh_host_rsa_key.pub)" > /etc/ssh/ssh_known_hosts
    cp -p /etc/ssh/ssh_known_hosts $SNOW_CONF/system_files/etc/ssh/ssh_known_hosts
    # Generate /etc/ssh/shosts.equiv
    bkp /etc/ssh/shosts.equiv
    echo ${host[*]} | tr " " "\n" | sed 's/^/+/g' > /etc/ssh/shosts.equiv
    cp -p /etc/ssh/shosts.equiv $SNOW_CONF/system_files/etc/ssh/shosts.equiv
    bkp /root/.shosts
    cp /etc/ssh/shosts.equiv /root/.shosts
    # Update /etc/ssh/ssh_config
    bkp /etc/ssh/ssh_config
    if [[ ! $(grep -q "HostbasedAuthentication yes" /etc/ssh/ssh_config) ]]; then
        echo "    HostbasedAuthentication yes" >> /etc/ssh/ssh_config
        echo "    GlobalKnownHostsFile /etc/ssh/ssh_known_hosts" >> /etc/ssh/ssh_config
        echo "    StrictHostKeyChecking no" >> /etc/ssh/ssh_config
    fi

    # Download linux kernel to boot OS from PXE defined in snow.conf
    # CentOS 7
    read -p "Do you want to download PXE bootable kernels (Y/n)? " -n 1 -r
    echo    ## move to a new line
    if [[ $REPLY =~ ^[Nn]$ ]]; then
        echo "PXE boot will not work unless you use a proper kernel. Manual setup will be required."
    else
        if [[ ! -d $SNOW_PATH/OS/deploy/kickstart/centos-7.0 ]]; then
            mkdir -p $SNOW_PATH/OS/deploy/kickstart/centos-7.0
        fi
        download http://buildlogs.centos.org/centos/7/os/x86_64-latest/images/pxeboot/initrd.img $SNOW_PATH/OS/deploy/kickstart/centos-7.0/ 
        download http://buildlogs.centos.org/centos/7/os/x86_64-latest/images/pxeboot/vmlinuz $SNOW_PATH/OS/deploy/kickstart/centos-7.0/
    fi
    # Download the ISO in order to create the local repo defined in snow.conf

}

function update_tools() {
if [[ ! -d $SNOW_TOOL ]]; then
    mkdir -p $SNOW_TOOL
    cd $SNOW_TOOL
    git clone http://bitbucket.org/hpcnow/snow-tools.git || error_exit "ERROR: please review the SSH certificates in your bitbucket."
    cd -
else
    cd $SNOW_TOOL
    git pull http://bitbucket.org/hpcnow/snow-tools.git || error_exit "ERROR: please review the SSH certificates in your bitbucket."
fi 
}

function update_configspace() {
if [[ ! -d $SNOW_CONF  ]]; then
    mkdir -p $SNOW_CONF
    cd $SNOW_CONF
    git clone http://bitbucket.org/hpcnow/snow-configspace.git || error_exit "ERROR: please review the SSH certificates in your bitbucket."
    cd -
else
    if [[ -z "$TOKEN" || -z "$PRIVATE_REPO" ]]; then
        error_exit "ERROR: your private git repo and token are not defined. sNow! is not able to update without these two parameters."
        exit 1
    fi
    cd $SNOW_CONF
    git pull https://$TOKEN:x-oauth-basic@$PRIVATE_REPO || error_exit "ERROR: please review the SSH certificates in your bitbucket."
fi
}

function update_xen_image() {
if [[ ! -d $SNOW_PATH/domains/template ]]; then
    mkdir -p $SNOW_PATH/domains/template
    wget http://repo.hpcnow.com/snow-template.md5sum -P $SNOW_PATH/domains/template || error_exit "ERROR: the image can not be downloaded. Please check your network setup."
    wget http://repo.hpcnow.com/snow-template.tar.bz2 -P $SNOW_PATH/domains/template || error_exit "ERROR: the image can not be downloaded. Please check your network setup."
else
    if [[ -f $SNOW_PATH/domains/template/snow-template.tar.bz2 ]]; then
        MD5LOCAL=$(md5sum $SNOW_PATH/domains/template/snow-template.tar.bz2 | gawk '{ print $1 }')
        wget http://repo.hpcnow.com/snow-template.md5sum -P $SNOW_PATH/domains/template || error_exit "ERROR: the image can not be downloaded. Please check your network setup."
        MD5HPCNOW=$(cat $SNOW_PATH/domains/template/snow-template.md5sum | gawk '{ print $1 }')
        if [[ "$MD5LOCAL" != "$MD5HPCNOW" ]]; then
            echo "Downloading most recent sNow! domain template"
            wget http://repo.hpcnow.com/snow-template.tar.bz2 -P $SNOW_PATH/domains/template || error_exit "ERROR: the image can not be downloaded. Please check your network setup."
        else
            echo "sNow domain template is up-to-date."
        fi
    else
        wget http://repo.hpcnow.com/snow-template.tar.bz2 -P $SNOW_PATH/domains/template || error_exit "ERROR: the image can not be downloaded. Please check your network setup."
    fi
fi 
}

function xen_create() {
    get_server_distribution $1 
    if [[ -f $SNOW_PATH/snow-tools/etc/domains/$1.cfg ]]; then
        if [[ "$opt3" != "force" ]]; then
            echo "The domain $1 already exist, please use force option to overwrite the domain"
            exit 1
        else
            FORCE="--force"
        fi
    else
        IMG_STATUS=$(cat $SNOW_DOMAINS | grep "$opt2")
        if [[ ! $IMG_STATUS ]]; then
            echo "The domain $1 is NOT available in the $SNOW_DOMAINS."
            exit 1
        else
            echo "Deploying the domain $1. It can take few minutes. Please wait!"
        fi
    fi

    if [[ -n "$IMG_DST" ]]; then
        IMG_DST_OPT="--${IMG_DST}"
    fi 
    cat $SNOW_DOMAINS | grep "$opt2" | gawk -v force="$FORCE" -v img_dst=$IMG_DST_OPT -v pwd=$MASTERPWD '{
        hostname=$1; role=$2; dev_nic1=$3; ip_nic1=$4; bridge_nic1=$5; mac_nic1=$6; mask_nic1=$7; gw_nic1=$8
        }
        END{
        system("xen-create-image --config=/sNow/snow-tools/etc/xen-tools.conf --roledir=/sNow/snow-tools/etc/role.d --hostname="hostname" --mac="mac_nic1" --bridge="bridge_nic1" --ip="ip_nic1" --gateway="gw_nic1" --netmask="mask_nic1" --role=snow,"role" --copyhosts --password="pwd " "force" "img_dst)
        }' || error_exit "ERROR: unable to install the domain, please report the issue to HPCNow!"
}

function xen_delete() {
    get_server_distribution $1 
    if [[ ! -f $SNOW_PATH/snow-tools/etc/domains/$1.cfg ]]; then
        echo "There is no domain with this name. Please, review the name of the domain to be removed."
    else
        if [[ -n "$IMG_DST" ]]; then
            IMG_DST_OPT="--${IMG_DST}"
        fi 
        xen-delete-image $IMG_DST_OPT --hostname=$1
        rm -f $SNOW_PATH/snow-tools/etc/domains/$1.cfg
    fi
}

function create_base() {
    if [[ "$opt3" == "force" ]]; then
        FORCE="--force"
    fi 
    xen_create deploy
}

function node_rank() {
    if [[ $1 =~ \] ]]; then
        NPREFIX=$(echo $1 | cut -d[ -f1)
        NRANK=($(echo $1 | cut -d[ -f2| cut -d] -f1|  sed -e "s/-/ /"))
        NLENG=$(echo ${NRANK[1]}-${NRANK[0]} | bc -l)
    else 
        NLENG=0
    fi
}

function deploy_copy() {
    for i in $(eval echo "{${NRANK[0]}..${NRANK[1]}}")
    do 
        cp -p $SNOW_PATH/OS/deploy/pxelinux.cfg/$1 $SNOW_PATH/OS/deploy/pxelinux.cfg/$(gethostip $NPREFIX$i | gawk '{print $3}')
    done
}

function deploy() {
    if [[ -z "$1" ]]; then
        echo "ERROR: No domain or node to deploy"
        exit 1
    fi
    get_server_distribution $1
    echo "This will install $1. All the data contained in these nodes will be removed"
    read -p "Are you sure? (y/n) : " -n 1 -r
    echo 
    if [[ $REPLY =~ ^[Yy]$ ]]
    then
        if (($IS_VM)) ; then
            xen_create $1 $2
        else
            node_rank $1
            #BLOCKN=${2:-$BLOCKN}
            #BLOCKD=${3:-$BLOCKD}
            DEFAULT_TEMPLATE=${2:-$DEFAULT_TEMPLATE}
            if ! [[ -f $SNOW_PATH/OS/deploy/pxelinux.cfg/$DEFAULT_TEMPLATE ]] ; then
                echo "No template $DEFAULT_TEMPLATE available in $SNOW_PATH/OS/deploy/pxelinux.cfg"
                exit 1
            fi
            if (( $NLENG > 0 )); then
                echo "Deploying node range $1 ... This will take a while, Please wait"
                #parallel -j $BLOCKN snow check_host_status "$NPREFIX{}-bmc" ::: $(eval echo "{${NRANK[0]}..${NRANK[1]}}")
                deploy_copy $DEFAULT_TEMPLATE
                parallel -j $BLOCKN \
                echo "Deploying node : $NPREFIX{} ... Please wait" \; \
                ipmitool -I $IPMITYPE -H "$NPREFIX{}-bmc" -U $IPMIUSER -P $IPMIPWD power reset \; \
                sleep 5 \; \
                ipmitool -I $IPMITYPE -H "$NPREFIX{}-bmc" -U $IPMIUSER -P $IPMIPWD power on \; \
                sleep $BLOCKD \
                ::: $(eval echo "{${NRANK[0]}..${NRANK[1]}}")
                sleep $BOOT_DELAY
                echo "Setting up dis as boot device... Please wait"
                deploy_copy $DEFAULT_BOOT
            else
                check_host_status $1-bmc
                cp -p $SNOW_PATH/OS/deploy/pxelinux.cfg/$DEFAULT_TEMPLATE $SNOW_PATH/OS/deploy/pxelinux.cfg/$(gethostip $1 | gawk '{print $3}')
                ipmitool -I $IPMITYPE -H $1-${NET_IPMI[4]}-U $IPMIUSER -P $IPMIPWD power reset
                sleep 5
                ipmitool -I $IPMITYPE -H $1-${NET_IPMI[4]}-U $IPMIUSER -P $IPMIPWD power on
                echo "Deploying node : $1 ... Please wait"
                sleep $BOOT_DELAY
                cp -p $SNOW_PATH/OS/deploy/pxelinux.cfg/$DEFAULT_BOOT $SNOW_PATH/OS/deploy/pxelinux.cfg/$(gethostip $1 | gawk '{print $3}') 
            fi
        fi
    else
        echo
        echo "Well done. It's better to be sure."
    fi
}


function list() {
    xl list $opt2
}


function check_host_status(){
    PING=$(ping -c 1 $1 &> /dev/null)
    if [[ "$?" != "0" ]]; then
        echo "The host $1 is not responsive. Please check the host name, DNS server or /etc/hosts."
        exit 1
    fi 
}

function boot() {
    if [ -z "$1" ]; then
        echo "ERROR: No domain or node to boot."
        exit 1
    fi
    get_server_distribution $1
    if (($IS_VM)) ; then
        if [[ -f $SNOW_PATH/snow-tools/etc/domains/${1}${DOM_EXT}.cfg ]]; then 
            xl create $SNOW_PATH/snow-tools/etc/domains/${1}${DOM_EXT}.cfg
        else
            echo "The domain $1 needs to be deployed first: Execute : snow deploy $i"
            exit 1
        fi
    else
        node_rank $1
        BLOCKN=${2:-$BLOCKN}
        BLOCKD=${3:-$BLOCKD}
        if (( $NLENG > 1 )); then
            parallel -j $BLOCKN \
            echo "$NPREFIX{}-bmc" \; \
            sleep $BLOCKD \; \
            ipmitool -I $IPMITYPE -H "$NPREFIX{}-bmc" -U $IPMIUSER -P $IPMIPWD power on \
            ::: $(eval echo "{${NRANK[0]}..${NRANK[1]}}")
        else 
            check_host_status $1-bmc
            ipmitool -I $IPMITYPE -H $1-${NET_IPMI[4]}-U $IPMIUSER -P $IPMIPWD power on
        fi
    fi
}

function get_server_distribution(){
    node_rank $1
    if (( $NLENG > 0 )); then
        # VM ranks are not yet supported
        IS_VM=0
    else
        IS_VM=$(cat $SNOW_DOMAINS | gawk -v vm="$1" 'BEGIN{isvm=0}{if (match($1, vm)){isvm=1}}END{print isvm}')
    fi
}

function boot_domains() {
    for i in $(SELF_ACTIVE_DOMAINS)
    do 
        boot $i
    done
}

function boot_cluster() {
    if [ -z "$1" ]; then
        echo "ERROR: No cluster to boot."
        exit 1
    fi
    CLUSTERNAME=$1
    BLOCKN=${2:-$BLOCKN}
    BLOCKD=${3:-$BLOCKD}
    # In order to avoid power consumption peaks, the nodes needs to be booted in a blocks of few nodes with a delayed (5 seconds) timing between blocks 
    # BlockN is the number of nodes to be iniciated at the same time (default should be 5)
    # BlockD is the delay between one block and the following one (default 5 seconds)
    # GNU Parallel : Pass $BLOCKN + Sleep $BLOCKD
    boot ${CLUSTERS[$1]} 
}

function ncmd() {
    if [ -z "$1" ]; then
        echo "ERROR: No domain(s) or node(s) to execute command."
        exit 1
    fi
    pdsh -w $1 $2 $3 $4
}

function nreboot() {
    if [ -z "$1" ]; then
        echo "ERROR: No domain(s) or node(s) to reboot."
        exit 1
    fi
    pdsh -w $1 reboot
}

function nshutdown() {
    if [ -z "$1" ]; then
        echo "ERROR: No domain(s) or node(s) to shutdown."
        exit 1
    fi
    pdsh -w $1 systemctl poweroff
}

function shutdown_cluster() {
    if [ -z "$1" ]; then
        echo "ERROR: No cluster to shutdown."
        exit 1
    fi
    CLUSTERNAME=$1
    nshutdown ${CLUSTERS[$1]} 
}

function ndestroy() {
    if [ -z "$1" ]; then
        echo "ERROR: No domain(s) or node(s) to power down."
        exit 1
    fi
    get_server_distribution $1
    if (($IS_VM)) ; then
        xl destroy $1
    else
        node_rank $1
        BLOCKN=${2:-$BLOCKN}
        BLOCKD=${3:-$BLOCKD}
        if (( $NLENG > 1 )); then
            parallel -j $BLOCKN \
            echo "$NPREFIX{}-bmc" \; \
            ipmitool -I $IPMITYPE -H "$NPREFIX{}-bmc" -U $IPMIUSER -P $IPMIPWD power off \
            ::: $(eval echo "{${NRANK[0]}..${NRANK[1]}}")
        else
            check_host_status $1-bmc
            ipmitool -I $IPMITYPE -H $1-${NET_IPMI[4]}-U $IPMIUSER -P $IPMIPWD power off
        fi
    fi
}

function npoweroff() {
    if [ -z "$1" ]; then
        echo "ERROR: No domain(s) or node(s) to shutdown."
        exit 1
    fi
    get_server_distribution $1
    if (($IS_VM)) ; then
        xl shutdown $1
    else
        node_rank $1
        BLOCKN=${2:-$BLOCKN}
        BLOCKD=${3:-$BLOCKD}
        if (( $NLENG > 1 )); then
            parallel -j $BLOCKN \
            echo "$NPREFIX{}-bmc" \; \
            ipmitool -I $IPMITYPE -H "$NPREFIX{}-bmc" -U $IPMIUSER -P $IPMIPWD power soft \
            ::: $(eval echo "{${NRANK[0]}..${NRANK[1]}}")
        else
            check_host_status $1-bmc
            ipmitool -I $IPMITYPE -H $1-${NET_IPMI[4]}-U $IPMIUSER -P $IPMIPWD power soft
        fi
    fi
}

function nreset() {
    if [ -z "$1" ]; then
        echo "ERROR: No domain(s) or node(s) to reset."
        exit 1
    fi
    get_server_distribution $1
    if (($IS_VM)) ; then
        xl reboot -F $1
    else
        node_rank $1
        BLOCKN=${2:-$BLOCKN}
        BLOCKD=${3:-$BLOCKD}
        if (( $NLENG > 1 )); then
            parallel -j $BLOCKN \
            echo "$NPREFIX{}-bmc" \; \
            ipmitool -I $IPMITYPE -H "$NPREFIX{}-bmc" -U $IPMIUSER -P $IPMIPWD power reset \
            ::: $(eval echo "{${NRANK[0]}..${NRANK[1]}}")
        else
            check_host_status $1-bmc
            ipmitool -I $IPMITYPE -H $1-${NET_IPMI[4]}-U $IPMIUSER -P $IPMIPWD power reset
        fi
    fi
}

function nconsole() {
    if [ -z "$1" ]; then
        echo "ERROR: please specify the domain(s) or node(s) to connect."
        exit 1
    fi
    get_server_distribution $1
    if (($IS_VM)) ; then
        xl console $1
    else
        check_host_status $1-bmc
        ipmitool -I $IPMITYPE -H $1-${NET_IPMI[4]}-U $IPMIUSER -P $IPMIPWD sol deactivate
        sleep 1
        ipmitool -I $IPMITYPE -H $1-${NET_IPMI[4]}-U $IPMIUSER -P $IPMIPWD sol activate
    fi
}

function nuptime() {
    if [ -z "$1" ]; then
        echo "ERROR: please, specify the domain(s) or node(s) to check the uptime."
        exit 1
    fi
    pdsh -w $1 uptime 
}

#
# End Functions
#

#
# Start Cases
#
case $opt1 in
    init)
        init
    ;;
    config)
        config
    ;;
    update)
        case $opt2 in
            tools)
                update_tools
            ;;
            configspace)
                update_configspace
            ;;
            template)
                update_xen_image
            ;;
            *)
                echo "Update available options : update_tools, configspace, snow_template"
            ;;
        esac
    ;;
    remove)
        xen_delete $opt2
    ;;
    deploy)
        deploy $opt2 $opt3 $opt4 $opt5
    ;;
    create)
        case $opt2 in
            base)
                create_base
            ;;
            *)
                create $opt2
            ;;
        esac
    ;;
    list)
        list $opt2
    ;;
    takeover)
        takeover $opt2
    ;;
    boot)
        case $opt2 in
            domains)  
                boot_domains $opt3 
            ;;
            cluster)
                boot_cluster $opt3 $opt4 $opt5 
            ;;
            *)
                boot $opt2 $opt3 $opt4
            ;;
        esac
    ;;
    cmd)
        ncmd $opt2 $opt3 $opt4 $opt5
    ;;
    reboot)
        nreboot $opt2
    ;;
    reset)
        nreset $opt2
    ;;
    poweroff)
        npoweroff $opt2
    ;;
    shutdown)
        case $opt2 in
            cluster)
                shutdown_cluster $opt3 
            ;;
            *)
                nshutdown $opt2 
            ;;
        esac
    ;;
    destroy)
        ndestroy $opt2
    ;;
    console)
        nconsole $opt2
    ;;
    uptime)
        nuptime $opt2
    ;;
    help|-help|--help|\?|*)
      shelp
      ;;
  esac

#
# End Cases
#

#
# Log the sNow! activity
#

echo "$(date)    $USER    $@" >> $SNOW_PATH/log/snow_actions.log 
